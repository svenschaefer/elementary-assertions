A classic SaaS system is centered around an Organization as the primary tenant scope. The Organization is the isolation boundary for data access, policies, limits, and billing, and all business objects belong to exactly one Organization. An Organization typically has a name and optional display names, a status, created and updated timestamps, a region or data residency setting, an operating mode, references to billing and plan binding, and optional limit overrides. Common organization-level settings include security posture (for example MFA required), domain and invitation rules, default role or onboarding defaults, and compliance or contractual states such as accepted terms/privacy, data processing agreements, and retention rules.

Users are represented as Users in the product, and their affiliation to an Organization is modeled via a Membership, i.e., the relationship between User and Organization. A User typically has an email address (optionally verified), an optional username, a display name, profile fields such as avatar, language, and time zone, account status, and last login. Often this also includes security information such as configured MFA methods and the state of recovery or reset flows, as well as terms/privacy acceptance history if it is not managed exclusively at the Organization level. A Membership typically carries a status and status timestamps (invited, accepted, revoked), optional designation as owner or administrator, default associations such as a default team, and created and updated timestamps. Invitations are commonly represented as an Invitation object with target email, inviter, expiry time, desired role or team preselection, and status with timestamps. Teams or Groups bundle memberships; a Team has a name, description, and created and updated timestamps, and team membership records who is a member and since when.

Business work objects are typically modeled as Domain Resources. Very often there is a hierarchical structure of Resource Types and Resources: a Resource Type describes which business attributes, actions, lifecycle states, and relationships an object has, and whether it is a container or a leaf. A Resource is the concrete instance of a Resource Type and typically carries a name or title, description, status, created and updated timestamps, responsibility (owner), optional classification (tags, category, sensitivity), and relationships to other resources. In this model, “Project” is commonly a Resource Type, and a specific project is a Resource of that type. Projects usually serve as containers under the Organization to group resources, and typically carry name, description, status (active, archived), responsibility, visibility or access mode in a team context, and project-level settings. Under a project sit further resources such as documents or items, records, files and attachments, templates, workflows or pipelines, jobs or runs, and other product-specific objects, often complemented by folders or collections as an additional structuring layer. For collaboration and process, comments or notes, tasks or tickets, approvals or reviews, and activity or event objects are common; these reference a target object and typically have content, status, timestamps, and responsibilities. For integrations there are configurations such as webhooks or API integrations with event types, target address, status, and secret, as well as notification settings, and usually delivery logs with delivery attempts, retries, outcome status, and the timestamp of the last successful delivery.

Authorization is typically organized conceptually into three classes: Principals as subjects (commonly Membership, Team, and Service Accounts), Authorization Artifacts as the rule set (Permissions, Roles, Assignments, and optionally Policies), and Domain Resources as protected objects (projects and all downstream business objects). Permissions are atomic capabilities, usually expressed as a stable key with optional label and category. Roles bundle permissions and typically have name, description, classification as system vs custom role, and timestamps. Assignments bind roles to principals in a scope and typically record which role is assigned, to whom it is assigned, which scope it applies to, and who assigned it.

RBAC is the standard baseline: a principal receives roles in a scope, at minimum at the Organization level and often additionally at the Project level. This yields a baseline set of allowed actions for all domain resources within that scope. ACLs or grants complement this at the resource level when sharing or object-specific exceptions are needed: a grant binds a principal directly to a concrete resource and grants an access level or specific actions, independent of whether the principal is otherwise sufficiently authorized via scope roles. ABAC complements this as a condition layer by additionally making the decision depend on attributes of the principal, the resource, and the context, such as owner rules, classifications, project status, or security requirements. In the typical composition, RBAC provides the coarse baseline, ACLs or grants model targeted sharing and object-level exceptions, and ABAC acts as additional constraints or selective extra logic that contextually restricts or, in clearly defined cases, extends permissions derived from RBAC and grants.

For operations and security, common objects include sessions, tokens, API keys, and service accounts, as well as SSO connections and audit events. A session typically carries the signed-in context (who in which organization), start time, last activity, expiry time, and optional client context. Tokens are tracked with issuance time, expiry time, rotation, and revocation. API keys have name, creation time, last used time, optional expiry, revocation status, and allowed access scope. Service accounts have name, description, status, creation time, creator, and associated credentials. SSO connections include the connection type, IdP metadata, certificates or client configuration, claim mappings, allowed domains, active status, and timestamps. Audit events capture timestamp, acting identity, action, affected entity, optional request or trace context, client context such as IP and user agent, and a structured change record.

Commercial enablement is modeled via plan and subscription, complemented by entitlements for features and limits and usage or metering for consumption-based components. A plan has name, included features, standard limits, and pricing parameters. A subscription has the plan, status, period start and end, renewal parameters, purchased quantities such as seats, and created and updated timestamps. Entitlements are represented as feature switches and limit values, optionally with overrides. Usage or metering is represented as consumption entries per meter and time window with quantity and capture time. Billing data is modeled via a customer or billing account, including billing address, tax information, contact email, currency, payment terms, payment provider linkage, and status, complemented by invoices with billing period, line items, amounts, status, due date, and document, and payments or transactions with amount, status, timestamps, failure information, and the payment method used.